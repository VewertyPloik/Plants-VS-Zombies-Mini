<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini PvZ Lite</title>
<style>
  body {
    margin: 0; background: linear-gradient(#a9e4ff, #dff7ff);
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #ui {
    display: flex;
    justify-content: space-between;
    background: #fff;
    padding: 8px 12px;
    font-weight: bold;
    font-size: 18px;
    border-bottom: 2px solid #ccc;
    gap: 15px;
  }
  #game {
    display: flex;
    padding: 12px;
    gap: 10px;
  }
  #leftPanel {
    width: 220px;
  }
  button {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    margin-bottom: 10px;
    cursor: pointer;
  }
  #message {
    font-size: 14px;
    margin-top: 10px;
  }
  #canvasWrap {
    background: linear-gradient(#7adf3b, #3fb011);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.2);
  }
  canvas {
    border-radius: 6px;
    background: linear-gradient(#76c24d, #4aa02b);
    image-rendering: pixelated;
    display: block;
  }
  #popup {
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(50,50,50,0.9);
    color: white;
    font-size: 36px;
    padding: 30px 50px;
    border-radius: 12px;
    box-shadow: 0 0 15px black;
    z-index: 1000;
    display: none;
    text-align: center;
  }
</style>
</head>
<body>

<div id="ui">
  <div>‚òÄÔ∏è Sun: <span id="sunVal">5</span></div>
  <div id="waveText">Wave: 1 / 20</div>
  <div id="zombieCount">Zombies Left: 0</div>
  <div id="status">Status: Preparing</div>
  <div>‚ù§Ô∏è HP: <span id="hpVal">5</span></div>
</div>

<div id="game">
  <div id="leftPanel">
    <button id="selectPea">ü´õ Pea Shooter (10 Sun)</button>
    <button id="selectSunflower">üåª Sunflower (5 Sun)</button>
    <button id="selectPie">ü•ß Pie Bomb (8 Sun)</button>
    <button id="selectUpPea">ü´õ (Upgraded) Pea Shooter (20 Sun)</button>
    <div id="message">Select a plant, then click a grid cell to place. Click ‚òÄÔ∏è to collect sun.</div>
  </div>
  <div id="canvasWrap">
    <canvas id="c" width="1000" height="600"></canvas>
  </div>
</div>

<div id="popup"></div>

<script>
(() => {
  const ROWS = 5, COLS = 9;
  const CELL_W = 85, CELL_H = 100;
  const GRID_X = 10, GRID_Y = 10;

  const TOTAL_WAVES = 16;
  const START_SUN = 10;
  const START_HP = 5;

  let sun = START_SUN;
  let playerHP = START_HP;
  let currentWave = 1;
  let preparing = true;
  let prepareTimer = 5000;
  let waveActive = false;
  let selected = null;

  let grid = Array.from({length: ROWS}, () => Array(COLS).fill(null));
  let suns = [];
  let zombies = [];
  let projectiles = [];

  let zombiesSpawned = 0;
  let zombiesToSpawn = 0;
  let lastSunDrop = 0;
  let lastSunflowerDrop = 0;
  let lastZombieSpawn = 0;

  const sunVal = document.getElementById('sunVal');
  const waveText = document.getElementById('waveText');
  const status = document.getElementById('status');
  const hpVal = document.getElementById('hpVal');
  const message = document.getElementById('message');
  const popup = document.getElementById('popup');
  const zombieCount = document.getElementById('zombieCount');

  const costs = {
    pea: 10,
    sunflower: 5,
    pie: 8,
    uppea: 20,
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function drawHP(ctx, x, y, w, h, hp, maxHp) {
    ctx.fillStyle = 'red';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = 'limegreen';
    ctx.fillRect(x, y, w * (hp / maxHp), h);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
  }

  function showPopup(text) {
    gamePaused = true;
    popup.textContent = text;
    popup.style.display = 'block';
    setTimeout(() => {
      popup.style.display = 'none';
      if (text === "YOU WON!") {
        updateHighScore(currentWave);
        incrementWins();
        resetGame();
      } else if (text.startsWith("You died")) {
        updateHighScore(currentWave);
        resetGame();
      } else if (text.startsWith("Wave")) {
        currentWave++;
        waveText.textContent = `Wave: ${currentWave} / ${TOTAL_WAVES}`;
        prepareTimer = 5000;
        preparing = true;
        waveActive = false;
      }
      gamePaused = false;
    }, 3000);
  }

  function updateHighScore(wave) {
    const hs = getHighScore();
    if (wave > hs) localStorage.setItem('pvz_highscore', wave);
  }
  function getHighScore() {
    return parseInt(localStorage.getItem('pvz_highscore')) || 0;
  }
  function incrementWins() {
    let wins = parseInt(localStorage.getItem('pvz_wins')) || 0;
    wins++;
    localStorage.setItem('pvz_wins', wins);
  }

  function resetGame() {
    sun = START_SUN;
    playerHP = START_HP;
    currentWave = 1;
    preparing = true;
    prepareTimer = 5000;
    waveActive = false;
    zombiesSpawned = 0;
    zombiesToSpawn = 0;
    grid = Array.from({length: ROWS}, () => Array(COLS).fill(null));
    suns = [];
    zombies = [];
    projectiles = [];
    sunVal.textContent = sun;
    hpVal.textContent = playerHP;
    waveText.textContent = `Wave: ${currentWave} / ${TOTAL_WAVES}`;
    zombieCount.textContent = `Zombies Left: 0`;
    status.textContent = 'Status: Preparing';
    message.textContent = 'Select a plant, then click a grid cell to place. Click ‚òÄÔ∏è to collect sun.';
    selected = null;
  }

  canvas.addEventListener('click', e => {
    if (gamePaused) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Check click suns first (collect)
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i];
      if (mx >= s.x - 15 && mx <= s.x + 15 && my >= s.y - 20 && my <= s.y + 10) {
        sun++;
        sunVal.textContent = sun;
        suns.splice(i, 1);
        return;
      }
    }

    // Place plants on grid
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = GRID_X + c * CELL_W;
        const y = GRID_Y + r * CELL_H;
        if (mx >= x && mx < x + CELL_W && my >= y && my < y + CELL_H) {
          placePlant(r, c);
          return;
        }
      }
    }
  });

  function placePlant(r, c) {
    if (!selected) {
      message.textContent = "Select a plant first.";
      return;
    }
    if (grid[r][c]) {
      message.textContent = "That spot is occupied.";
      return;
    }
    if (sun < costs[selected]) {
      message.textContent = "Not enough Sun!";
      return;
    }
    sun -= costs[selected];
    sunVal.textContent = sun;

    if (selected === 'pea') {
      grid[r][c] = { type: 'pea', hp: 3, shootTimer: 0 };
    } else if (selected === 'uppea') {
      grid[r][c] = { type: 'uppea', hp: 3, shootTimer: 0 };
    } else if (selected === 'sunflower') {
      grid[r][c] = { type: 'sunflower', hp: 3, collectTimer: 0 };
    } else if (selected === 'pie') {
      grid[r][c] = { type: 'pie', hp: 1 };
    }
    message.textContent = "Plant placed!";
  }

  function spawnSunFromSky() {
    const x = GRID_X + Math.random() * (COLS * CELL_W - 30);
    suns.push({ x, y: -20, vy: 0.3, type: "sky" });
  }

function spawnZombie() {
  const r = Math.floor(Math.random() * ROWS);
  const y = GRID_Y + r * CELL_H + CELL_H / 2;
  const x = canvas.width + 40;

  // Base speed before wave 15
  let speedBaseWave = Math.min(currentWave, 4);
  let baseSpeed = 0.02 * Math.pow(2, speedBaseWave - 1);

  // At wave 15, speed doubles (2x)
  if (currentWave >= 15) {
    baseSpeed *= 2;
  }

  // Base health is 3, increased by 0.2x per wave starting wave 5 to 15 max
  let healthMultiplier = 1;
  if (currentWave >= 5 && currentWave <= 15) {
    healthMultiplier += 0.2 * (currentWave - 4); // +0.2 per wave starting at wave 5
  } else if (currentWave > 15) {
    healthMultiplier += 0.2 * (15 - 4); // capped at wave 15 scaling
  }
  const hp = 3 * healthMultiplier;

  const types = ['üßü', 'üßü‚Äç‚ôÄÔ∏è', 'üßü‚Äç‚ôÇÔ∏è'];
  const emoji = types[Math.floor(Math.random() * types.length)];
  zombies.push({ x, y, r, speed: baseSpeed, hp, emoji, attackAccum: 0 });
  zombiesSpawned++;
}

  }

  function firePea(r, c, upgraded) {
    const sx = GRID_X + c * CELL_W + CELL_W - 10;
    const sy = GRID_Y + r * CELL_H + CELL_H / 2;
    projectiles.push({ x: sx, y: sy, vx: 0.6, row: r, dmg: upgraded ? 2 : 1 });
  }

  let gamePaused = false;

  function update(dt) {
    if (gamePaused) return;

    lastSunDrop += dt;
    if (lastSunDrop > 3000) { // every 3 sec drop sun from sky
      spawnSunFromSky();
      lastSunDrop = 0;
    }

    lastSunflowerDrop += dt;
    if (lastSunflowerDrop > 2000) {
      // sunflowers drop suns
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const p = grid[r][c];
          if (p && p.type === 'sunflower') {
            suns.push({
              x: GRID_X + c * CELL_W + CELL_W / 2 + (Math.random() * 20 - 10),
              y: GRID_Y + r * CELL_H + 10,
              vy: 0.1,
              type: "sunflower"
            });
          }
        }
      }
      lastSunflowerDrop = 0;
    }

    if (preparing) {
      status.textContent = `Status: Preparing (${Math.ceil(prepareTimer / 1000)}s)`;
      prepareTimer -= dt;
      if (prepareTimer <= 0) {
        preparing = false;
        waveActive = true;
        zombiesSpawned = 0;
        zombiesToSpawn = 5 + (currentWave - 1) * 3;
        lastZombieSpawn = 0;
      }
    } else if (waveActive) {
      status.textContent = 'Status: Wave Active';
      lastZombieSpawn += dt;

      // spawn interval decreases with wave, but never < 600ms
      const spawnInterval = Math.max(600, 4000 - (currentWave - 1) * 180);

      if (lastZombieSpawn > spawnInterval && zombiesSpawned < zombiesToSpawn) {
        spawnZombie();
        lastZombieSpawn = 0;
      }

      // update zombies left display (spawn left + alive)
      const aliveZombies = zombies.length;
      const spawnLeft = zombiesToSpawn - zombiesSpawned;
      zombieCount.textContent = `Zombies Left: ${spawnLeft + aliveZombies}`;

      if (zombiesSpawned >= zombiesToSpawn && zombies.length === 0) {
        waveActive = false;
        if (currentWave >= TOTAL_WAVES) {
          showPopup("YOU WON!");
        } else {
          showPopup(`Wave ${currentWave} completed!`);
        }
      }
    }

    // Update suns falling
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i];
      if (s.type === "sky" || s.type === "sunflower") {
        s.y += s.vy * dt;
        if (s.y > canvas.height - 30) s.vy = 0;
      }
    }

    // Update projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.x += p.vx * dt;
      let hit = false;
      for (let j = zombies.length - 1; j >= 0; j--) {
        const z = zombies[j];
        if (z.r === p.row && Math.abs(p.x - z.x) < 18) {
          z.hp -= p.dmg;
          projectiles.splice(i, 1);
          if (z.hp <= 0) zombies.splice(j, 1);
          hit = true;
          break;
        }
      }
      if (!hit && p.x > canvas.width + 50) {
        projectiles.splice(i, 1);
      }
    }

    // Update zombies
    for (let i = zombies.length - 1; i >= 0; i--) {
      const z = zombies[i];
      z.x -= z.speed * dt;

      if (z.x < GRID_X) {
        zombies.splice(i, 1);
        playerHP--;
        hpVal.textContent = playerHP;
        if (playerHP <= 0) {
          showPopup(`You died on wave ${currentWave}. High score: ${getHighScore()}`);
        }
        continue;
      }

      const col = Math.floor((z.x - GRID_X) / CELL_W);
      let attackedPlant = false;

      for (let dc = 0; dc <= 1; dc++) {
        const cc = col - dc;
        if (cc >= 0 && cc < COLS) {
          const p = grid[z.r][cc];
          if (p && p.type !== 'pie') {
            p.attackAccum = (p.attackAccum || 0) + dt;
            if (p.attackAccum >= 3000) { // 3 sec attack to damage plant
              p.hp--;
              p.attackAccum = 0;
              if (p.hp <= 0) {
                grid[z.r][cc] = null;
                message.textContent = "A plant was destroyed!";
              }
            }
            attackedPlant = true;
            break;
          }
        }
      }
      if (!attackedPlant) {
        for (let c = 0; c < COLS; c++) {
          const p = grid[z.r][c];
          if (p) p.attackAccum = 0;
        }
      }

      // Pie bomb explode if zombie close
      for (let c = 0; c < COLS; c++) {
        const p = grid[z.r][c];
        if (p && p.type === 'pie') {
          const pieX = GRID_X + c * CELL_W + CELL_W / 2;
          if (Math.abs(z.x - pieX) < CELL_W + 10) {
            grid[z.r][c] = null;
            zombies.splice(i, 1);
            message.textContent = "Pie bomb exploded!";
            break;
          }
        }
      }
    }

    // Plants shoot peas
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const p = grid[r][c];
        if (p && (p.type === 'pea' || p.type === 'uppea')) {
          p.shootTimer += dt;
          const cooldown = p.type === 'uppea' ? 1500 : 3000;
          if (p.shootTimer >= cooldown) {
            p.shootTimer = 0;
            if (zombies.some(z => z.r === r && z.x > GRID_X + c * CELL_W)) {
              firePea(r, c, p.type === 'uppea');
            }
          }
        }
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const x = GRID_X + c * CELL_W;
        const y = GRID_Y + r * CELL_H;
        ctx.strokeRect(x, y, CELL_W, CELL_H);
      }
    }

    // Draw plants
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.font = '48px Arial';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const p = grid[r][c];
        if (!p) continue;
        const x = GRID_X + c * CELL_W + CELL_W / 2;
        const y = GRID_Y + r * CELL_H + CELL_H / 2;
        let text = '';
        let outline = false;
        if (p.type === 'pea') text = 'ü´õ';
        else if (p.type === 'uppea') {
          text = 'ü´õ';
          outline = true;
        } else if (p.type === 'sunflower') text = 'üåª';
        else if (p.type === 'pie') text = 'ü•ß';

        if (outline) {
          ctx.lineWidth = 6;
          ctx.strokeStyle = 'red';
          ctx.strokeText(text, x, y);
          ctx.lineWidth = 1;
        }
        ctx.fillStyle = 'black';
        ctx.fillText(text, x, y);

        // Draw HP bar
        drawHP(ctx, x - 30, y + 30, 60, 8, p.hp, p.type === 'pie' ? 1 : 3);
      }
    }

    // Draw zombies
    ctx.font = '48px Arial';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    for (const z of zombies) {
      ctx.fillStyle = 'black';
      ctx.fillText(z.emoji, z.x, z.y);
      drawHP(ctx, z.x - 30, z.y + 30, 60, 8, z.hp, 3);
    }

    // Draw projectiles
    ctx.fillStyle = 'limegreen';
    for (const p of projectiles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw suns
    ctx.font = '28px Arial';
    suns.forEach(s => {
      ctx.fillText("‚òÄÔ∏è", s.x, s.y);
    });
  }

  // Buttons
  document.getElementById('selectPea').onclick = () => {
    selected = 'pea';
    message.textContent = "Selected Pea Shooter";
  };
  document.getElementById('selectSunflower').onclick = () => {
    selected = 'sunflower';
    message.textContent = "Selected Sunflower";
  };
  document.getElementById('selectPie').onclick = () => {
    selected = 'pie';
    message.textContent = "Selected Pie Bomb";
  };
  document.getElementById('selectUpPea').onclick = () => {
    selected = 'uppea';
    message.textContent = "Selected Upgraded Pea Shooter";
  };

  // Game loop
  let lastTime = 0;
  function loop(time = 0) {
    const dt = time - lastTime;
    lastTime = time;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  resetGame();
  loop();

})();
</script>

</body>
</html>
